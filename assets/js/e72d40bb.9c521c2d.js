"use strict";(self.webpackChunkdsa_study_guide=self.webpackChunkdsa_study_guide||[]).push([[925],{6339:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"algorithms/two-pointers","title":"Two Pointers","description":"Understanding two pointers algorithm","source":"@site/docs/algorithms/two-pointers.mdx","sourceDirName":"algorithms","slug":"/algorithms/two-pointers","permalink":"/docs/algorithms/two-pointers","draft":false,"unlisted":false,"editUrl":"https://github.com/LuluBeatson/dsa-study-guide/tree/main/docs/algorithms/two-pointers.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Two Pointers","description":"Understanding two pointers algorithm"},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/docs/algorithms/overview"},"next":{"title":"Sliding Window (Fixed)","permalink":"/docs/algorithms/sliding-window"}}');var i=s(4848),t=s(8453),a=s(5537),l=s(9329);s(8069);const o={sidebar_position:1,title:"Two Pointers",description:"Understanding two pointers algorithm"},d="Two Pointers",h={},c=[{value:"Template",id:"template",level:2},{value:"Example: Remove Duplicates from Sorted Array",id:"example-remove-duplicates-from-sorted-array",level:2},{value:"When to Use Two Pointers",id:"when-to-use-two-pointers",level:2},{value:"When Not to Use Two Pointers",id:"when-not-to-use-two-pointers",level:2},{value:"Conclusion",id:"conclusion",level:2}];function m(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"two-pointers",children:"Two Pointers"})}),"\n",(0,i.jsxs)(n.p,{children:["Two pointers algorithms are used to solve problems that involve sorted arrays, pairs, or sub-arrays/sub-strings efficiently to avoid the ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n^2)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]})," complexity of nested loops."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity:"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The two pointers move independently. They can be from the same end or different ends of the array. ",(0,i.jsx)(n.a,{href:"/docs/algorithms/sliding-window",children:"Sliding Window (Fixed)"})," and ",(0,i.jsx)(n.a,{href:"/docs/algorithms/sliding-window-dynamic",children:"Sliding Window (Dynamic)"})," are variants of two pointers."]}),"\n",(0,i.jsx)(n.h2,{id:"template",children:"Template"}),"\n",(0,i.jsxs)(a.A,{children:[(0,i.jsx)(l.A,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def two_pointers(arr):\n    left, right = 0, len(arr) - 1\n    result = 0\n    while left < right:\n        # Process elements at left and right pointers\n        # Move pointers based on condition\n        if condition:\n            left += 1\n        else:\n            right -= 1\n    return result\n"})})}),(0,i.jsx)(l.A,{value:"go",label:"Golang",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func twoPointers(arr []int) int {\n    left, right := 0, len(arr)-1\n    result := 0\n    for left < right {  // Golang\'s "WHILE" is written as "FOR"\n        // Process elements at left and right pointers\n        // Move pointers based on condition\n        if condition {\n            left++\n        } else {\n            right--\n        }\n    }\n    return result\n}\n'})})})]}),"\n",(0,i.jsx)(n.h2,{id:"example-remove-duplicates-from-sorted-array",children:"Example: Remove Duplicates from Sorted Array"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/remove-duplicates-from-sorted-array/",children:"LeetCode 26"})}),"\n",(0,i.jsxs)(n.p,{children:["Given a sorted in non-decreasing array, remove duplicates in-place by reordering such that the first ",(0,i.jsx)(n.code,{children:"k"})," elements contain unique elements in the order they were present in the original array. Return ",(0,i.jsx)(n.code,{children:"k"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"right"})," is the index being scanned ahead of ",(0,i.jsx)(n.code,{children:"left"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"left"})," is the index of the last unique element"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"result"})," is the number of unique elements in the array is ",(0,i.jsx)(n.code,{children:"left + 1"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"condition"})," is ",(0,i.jsx)(n.code,{children:"arr[left] == arr[right]"})]}),"\n"]}),"\n",(0,i.jsx)(a.A,{children:(0,i.jsx)(l.A,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def remove_duplicates(arr):\n    left, right = 0, 1\n    while right < len(arr):\n        if arr[left] == arr[right]:\n            right += 1\n        else:\n            left += 1\n            arr[left] = arr[right]\n            right += 1\n\n    return left + 1\n"})})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Visualization"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"1 1 2 2 3 3 4 4 5 5  (L = 0, R = 1)\nL R\n\n1 1 2 2 3 3 4 4 5 5  (R++)\nL   R\n\n1 2 2 2 3 3 4 4 5 5  (L++, arr[L] <- arr[R])\n  L R\n  ^\n\n1 2 2 2 3 3 4 4 5 5  (R++)\n  L   R\n\n1 2 2 2 3 3 4 4 5 5  (R++)\n  L     R\n\n1 2 3 2 3 3 4 4 5 5  (L++, arr[L] <- arr[R])\n    L   R\n    ^\n\n...\n\n1 2 3 4 5 3 4 4 5 5  (K = L + 1 = 5)\n        L         R\n"})}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-two-pointers",children:"When to Use Two Pointers"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sorted Arrays"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the input array is sorted (or can be sorted), two pointers can efficiently find pairs or ranges of elements that meet certain conditions (e.g., finding two numbers that sum to a target)."}),"\n",(0,i.jsx)(n.li,{children:'Example: In the "Two Sum II" problem, you can use two pointers starting from both ends of the sorted array.'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Finding Pairs"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When the problem involves finding pairs of elements that satisfy a specific condition (e.g., sum, product), two pointers can help avoid the (O(n^2)) complexity of nested loops."}),"\n",(0,i.jsx)(n.li,{children:'Example: In the "Container With Most Water" problem, two pointers can be used to maximize the area between two lines.'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Subarray Problems"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"For problems that require finding a subarray that meets certain criteria (e.g., maximum sum, longest unique substring), two pointers can help maintain a sliding window."}),"\n",(0,i.jsx)(n.li,{children:'Example: In the "Longest Substring Without Repeating Characters" problem, you can use two pointers to track the start and end of the current substring.'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Merging or Partitioning"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When merging two sorted arrays or partitioning an array based on a condition, two pointers can help traverse both arrays efficiently."}),"\n",(0,i.jsx)(n.li,{children:"Example: Merging two sorted lists into one sorted list."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Space Efficiency"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the problem requires in-place modifications or has constraints on space usage, two pointers can help achieve the desired result without additional data structures."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-not-to-use-two-pointers",children:"When Not to Use Two Pointers"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Unsorted Arrays"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the array is unsorted and you need to find pairs or elements based on conditions that require knowledge of the entire array, two pointers may not be effective."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Complex Conditions"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the condition for moving the pointers is complex and cannot be easily defined, a brute-force approach might be more straightforward."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Non-linear Structures"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"For problems involving trees or graphs, other traversal methods (like depth-first or breadth-first search) may be more appropriate."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"In summary, the two pointers technique is particularly useful for problems involving sorted arrays, pairs, and subarrays where you can maintain a linear traversal. If you find yourself needing to check all pairs of indices, consider whether the problem can be simplified by sorting the array or using a sliding window approach with two pointers."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);