"use strict";(self.webpackChunkdsa_study_guide=self.webpackChunkdsa_study_guide||[]).push([[950],{786:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"algorithms/sliding-window-dynamic","title":"Sliding Window (Dynamic)","description":"Understanding sliding window algorithm","source":"@site/docs/algorithms/sliding-window-dynamic.mdx","sourceDirName":"algorithms","slug":"/algorithms/sliding-window-dynamic","permalink":"/docs/algorithms/sliding-window-dynamic","draft":false,"unlisted":false,"editUrl":"https://github.com/LuluBeatson/dsa-study-guide/edit/main/docs/algorithms/sliding-window-dynamic.mdx","tags":[],"version":"current","sidebarPosition":2.5,"frontMatter":{"sidebar_position":2.5,"title":"Sliding Window (Dynamic)","description":"Understanding sliding window algorithm"},"sidebar":"tutorialSidebar","previous":{"title":"Sliding Window (Fixed)","permalink":"/docs/algorithms/sliding-window"},"next":{"title":"Binary Search","permalink":"/docs/algorithms/binary-search"}}');var t=i(4848),r=i(8453),l=i(5537),a=i(9329);i(8069);const d={sidebar_position:2.5,title:"Sliding Window (Dynamic)",description:"Understanding sliding window algorithm"},o="Sliding Window (Dynamic Size)",c={},h=[{value:"Template",id:"template",level:2},{value:"Example: Longest Substring Without Repeating Characters",id:"example-longest-substring-without-repeating-characters",level:2},{value:"Example: Longest Substring With Up To K Unique Characters",id:"example-longest-substring-with-up-to-k-unique-characters",level:2}];function m(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"sliding-window-dynamic-size",children:"Sliding Window (Dynamic Size)"})}),"\n",(0,t.jsxs)(n.p,{children:["The sliding window algorithm is used to solve problems that involve finding the maximum or minimum sum of a subarray of a ",(0,t.jsx)(n.strong,{children:"dynamic"})," size. It is very similar to the ",(0,t.jsx)(n.a,{href:"/docs/algorithms/two-pointers",children:"Two Pointers"})," algorithm."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mn,{children:"1"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord",children:"1"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]})]}),"\n",(0,t.jsx)(n.h2,{id:"template",children:"Template"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"window"})," is some value computed from the current window"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"result"})," is the result of the problem which may be updated from the current window"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"condition"})," is the condition that determines whether the window should be shrunk from the left"]}),"\n"]}),"\n",(0,t.jsx)(l.A,{children:(0,t.jsx)(a.A,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def sliding_window(arr: list) -> int:\n    left = 0\n    window = None\n    result = None\n\n    for right in range(len(arr)):\n        # Process window (add right element)\n        window = ...\n\n        while condition:\n            # Process window (remove left element)\n            window = ...\n\n            left += 1\n\n        # Update result\n        result = ...\n\n    return result\n"})})})}),"\n",(0,t.jsx)(n.h2,{id:"example-longest-substring-without-repeating-characters",children:"Example: Longest Substring Without Repeating Characters"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of finding the longest substring without repeating characters using the sliding window technique."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"window"})," (dictionary) is the count of characters in the current window"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"result"})," (string) is the longest substring without repeating characters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"condition"})," shrinks the window from the left if the current window now contains a repeating character due to the addition of a new character from the right"]}),"\n"]}),"\n",(0,t.jsx)(l.A,{children:(0,t.jsx)(a.A,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def longest_substring_without_repeating_characters(s: str) -> str:\n    left = 0\n    window = {}  # Count of characters in the current window\n    result = ""  # Longest substring without repeating characters\n\n    for right in range(len(s)):\n        # Process window (add right character)\n        window[s[right]] = window.get(s[right], 0) + 1\n\n        while window[s[right]] > 1:\n            # Process window (remove left character)\n            window[s[left]] -= 1\n            left += 1\n\n        # Update result\n        if len(window) > len(result):\n            result = s[left:right+1]\n\n    return result\n'})})})}),"\n",(0,t.jsxs)(n.p,{children:["You could also return the ",(0,t.jsx)(n.strong,{children:"length"})," of the longest substring by doing ",(0,t.jsx)(n.code,{children:"result = right - left + 1"})," instead of ",(0,t.jsx)(n.code,{children:"result = s[left:right+1]"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"example-longest-substring-with-up-to-k-unique-characters",children:"Example: Longest Substring With Up To K Unique Characters"}),"\n",(0,t.jsxs)(n.p,{children:["Here's an example of finding the longest substring with up to ",(0,t.jsx)(n.code,{children:"k"})," unique characters using the sliding window technique."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"window"})," (dictionary) is the count of characters in the current window"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"result"})," (string) is the longest substring with up to ",(0,t.jsx)(n.code,{children:"k"})," unique characters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"k"})," (integer) represents the maximum number of unique characters allowed in the current window. For this specific case, ",(0,t.jsx)(n.code,{children:"k"})," should be set to 1 to ensure no repeating characters."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"condition"})," shrinks the window from the left if the current window now contains more than ",(0,t.jsx)(n.code,{children:"k"})," unique characters"]}),"\n"]}),"\n",(0,t.jsx)(l.A,{children:(0,t.jsx)(a.A,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def longest_substring_with_k_unique_characters(s: str, k: int = 1) -> int:  # Default k to 1\n    left = 0\n    window = {}  # Count of characters in the current window\n    result = ""  # Longest substring with up to k unique characters\n\n    for right in range(len(s)):\n        # Process window (add right character)\n        window[s[right]] = window.get(s[right], 0) + 1\n        \n        # Shrink window from the left if condition is met\n        while len(window) > k:  # Here, k is the max number of unique characters allowed in the current window\n            # Process window (remove left character)\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        # Update result\n        if len(window) > len(result):\n            result = s[left:right+1]\n\n    return result\n'})})})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);