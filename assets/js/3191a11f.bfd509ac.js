"use strict";(self.webpackChunkdsa_study_guide=self.webpackChunkdsa_study_guide||[]).push([[794],{7625:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>h,contentTitle:()=>d,default:()=>p,frontMatter:()=>r,metadata:()=>n,toc:()=>m});const n=JSON.parse('{"id":"algorithms/backtracking","title":"Backtracking","description":"Understanding backtracking algorithm","source":"@site/docs/algorithms/backtracking.mdx","sourceDirName":"algorithms","slug":"/algorithms/backtracking","permalink":"/docs/algorithms/backtracking","draft":false,"unlisted":false,"editUrl":"https://github.com/LuluBeatson/dsa-study-guide/tree/main/docs/algorithms/backtracking.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Backtracking","description":"Understanding backtracking algorithm"},"sidebar":"tutorialSidebar","previous":{"title":"Dynamic Programming","permalink":"/docs/algorithms/dynamic-programming"}}');var t=a(4848),i=a(8453),l=a(5537),c=a(9329);a(8069);const r={sidebar_position:7,title:"Backtracking",description:"Understanding backtracking algorithm"},d="Backtracking",h={},m=[{value:"Template",id:"template",level:2},{value:"Example: Subsets",id:"example-subsets",level:2}];function o(e){const s={annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"backtracking",children:"Backtracking"})}),"\n",(0,t.jsx)(s.p,{children:'Backtracking is an algorithmic technique that considers searching every possible combination in order to solve a computational problem. It builds candidates to the solution incrementally and abandons candidates ("backtracks") when it determines that the candidate cannot lead to a valid solution.'}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Time Complexity:"})," Usually ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsxs)(s.msup,{children:[(0,t.jsx)(s.mn,{children:"2"}),(0,t.jsx)(s.mi,{children:"n"})]}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(2^n)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord",children:"2"}),(0,t.jsx)(s.span,{className:"msupsub",children:(0,t.jsx)(s.span,{className:"vlist-t",children:(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"0.6644em"},children:(0,t.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(s.span,{className:"mord mathnormal mtight",children:"n"})})]})})})})})]}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," or ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"n"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"!"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n!)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(s.span,{className:"mclose",children:"!)"})]})})]})," depending on the problem"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Space Complexity:"})," ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"O"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"n"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})})]})," for recursion stack"]}),"\n",(0,t.jsx)(s.h2,{id:"template",children:"Template"}),"\n",(0,t.jsx)(l.A,{children:(0,t.jsx)(c.A,{value:"py",label:"Python",children:(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'def backtrack(candidates: list, path: list, result: list):\n    if condition:\n        result.append(path[:])\n        return\n    for candidate in candidates:\n        path.append(candidate)\n        backtrack(candidates, path, result)\n        path.pop()  # "backtrack" = remove the last appended element\n'})})})}),"\n",(0,t.jsx)(s.h2,{id:"example-subsets",children:"Example: Subsets"}),"\n",(0,t.jsx)(s.p,{children:"Here's an example of generating all possible subsets of a set using backtracking."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"condition"}),": The stop condition in this case is when the length of the path is equal to the length of the candidates, indicating that a complete subset (the whole set) has been formed."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"candidates"}),": The set of elements to generate subsets from."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"path"}),": The current subset being built."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"result"}),": The list of all subsets."]}),"\n"]}),"\n",(0,t.jsx)(l.A,{children:(0,t.jsx)(c.A,{value:"py",label:"Python",children:(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'def backtrack(candidates: list, path: list, result: list):\n    if len(path) == len(candidates):\n        result.append(path[:])\n        return\n    for candidate in candidates:\n        path.append(candidate)\n        backtrack(candidates, path, result)\n        path.pop()  # "backtrack" = remove the last appended element\n\n\ndef subsets(candidates: list):\n    result = []  # To be mutated\n    backtrack(candidates, [], result)\n    return result\n\n\n# Example usage\ncandidates = [1, 2, 3]\nresult = subsets(candidates)\n'})})})})]})}function p(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);