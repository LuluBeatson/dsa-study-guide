"use strict";(self.webpackChunkdsa_study_guide=self.webpackChunkdsa_study_guide||[]).push([[794],{7625:(s,n,e)=>{e.r(n),e.d(n,{assets:()=>h,contentTitle:()=>m,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"algorithms/backtracking","title":"Backtracking","description":"Understanding backtracking algorithm","source":"@site/docs/algorithms/backtracking.mdx","sourceDirName":"algorithms","slug":"/algorithms/backtracking","permalink":"/docs/algorithms/backtracking","draft":false,"unlisted":false,"editUrl":"https://github.com/LuluBeatson/dsa-study-guide/tree/main/docs/algorithms/backtracking.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Backtracking","description":"Understanding backtracking algorithm"},"sidebar":"tutorialSidebar","previous":{"title":"Dynamic Programming","permalink":"/docs/algorithms/dynamic-programming"}}');var t=e(4848),r=e(8453),i=e(5537),c=e(9329);e(8069);const l={sidebar_position:7,title:"Backtracking",description:"Understanding backtracking algorithm"},m="Backtracking",h={},d=[{value:"Implementation",id:"implementation",level:2}];function o(s){const n={annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,r.R)(),...s.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"backtracking",children:"Backtracking"})}),"\n",(0,t.jsx)(n.p,{children:'Backtracking is an algorithmic technique that considers searching every possible combination in order to solve a computational problem. It builds candidates to the solution incrementally and abandons candidates ("backtracks") when it determines that the candidate cannot lead to a valid solution.'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," Usually ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsxs)(n.msup,{children:[(0,t.jsx)(n.mn,{children:"2"}),(0,t.jsx)(n.mi,{children:"n"})]}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(2^n)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsxs)(n.span,{className:"mord",children:[(0,t.jsx)(n.span,{className:"mord",children:"2"}),(0,t.jsx)(n.span,{className:"msupsub",children:(0,t.jsx)(n.span,{className:"vlist-t",children:(0,t.jsx)(n.span,{className:"vlist-r",children:(0,t.jsx)(n.span,{className:"vlist",style:{height:"0.6644em"},children:(0,t.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(n.span,{className:"mord mathnormal mtight",children:"n"})})]})})})})})]}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]})," or ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"!"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n!)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(n.span,{className:"mclose",children:"!)"})]})})]})," depending on the problem"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]})," for recursion stack"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of generating all possible subsets of a set using backtracking:"}),"\n",(0,t.jsxs)(i.A,{children:[(0,t.jsx)(c.A,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def subsets(nums):\n    result = []\n    \n    def backtrack(start, path):\n        # Add current subset to result\n        result.append(path[:])\n        \n        # Try all possible numbers that can be added\n        for i in range(start, len(nums)):\n            # Add current number to path\n            path.append(nums[i])\n            # Recursively generate subsets starting from next number\n            backtrack(i + 1, path)\n            # Remove current number (backtrack)\n            path.pop()\n    \n    backtrack(0, [])\n    return result\n\n# Example usage:\n# nums = [1, 2, 3]\n# Output: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n"})})}),(0,t.jsx)(c.A,{value:"ts",label:"Golang",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func subsets(nums []int) [][]int {\n    result := make([][]int, 0)\n    \n    var backtrack func(start int, path []int)\n    backtrack = func(start int, path []int) {\n        // Add current subset to result\n        pathCopy := make([]int, len(path))\n        copy(pathCopy, path)\n        result = append(result, pathCopy)\n        \n        // Try all possible numbers that can be added\n        for i := start; i < len(nums); i++ {\n            // Add current number to path\n            path = append(path, nums[i])\n            // Recursively generate subsets starting from next number\n            backtrack(i + 1, path)\n            // Remove current number (backtrack)\n            path = path[:len(path)-1]\n        }\n    }\n    \n    backtrack(0, []int{})\n    return result\n}\n\n// Example usage:\n// nums := []int{1, 2, 3}\n// Output: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n"})})})]})]})}function p(s={}){const{wrapper:n}={...(0,r.R)(),...s.components};return n?(0,t.jsx)(n,{...s,children:(0,t.jsx)(o,{...s})}):o(s)}}}]);